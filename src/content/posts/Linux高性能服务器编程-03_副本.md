---
title: Linux高性能服务器编程-03
description: 简介服务器模型；服务器编程框架；I/O模型；事件处理模式
pubDate: 2025-07-06
---

[TOC]

## 服务器模型

### C/S模型

客户端通过访问服务器获取所需资源，二者地位不对等。

#### 模型逻辑

服务器启动，创建一个或多个监听socket，并调用bind函数将其绑定到端口上，调用listen函数等待客户连接。

客户端使用connect函数向服务器发起连接，服务器使用某种I/O模型来监听这一事件。监听到连接请求后，服务器调用accept函数接受它，并分配一个逻辑单元为新的连接服务。

逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端；客户端收到返回结果后可以继续发送请求也可以关闭连接。

若客户端主动关闭连接，则服务器被动关闭连接，双方通信结束。

### P2P模型

摒弃了以服务器为中心的格局，相当于每台机器既是客户端又是服务器。

问题是主机间很难相互发现，所以需要一个专门的发现服务器，使每个客户可以尽快找到自己需要的资源。

## 服务器编程框架

```
I/O处理单元---请求队列---逻辑单元*n---请求队列---网络存储单元
```

| 模块         | 单个服务器程序             | 服务器机群                   |
| ------------ | -------------------------- | ---------------------------- |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库、文件或缓存     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间的永久TCP连接    |

## 同步I/O模型

socket创建时默认是阻塞的，可以设置参数SOCK_NONBLOCK设置其为非阻塞的。

阻塞文件描述符称作阻塞I/O；非阻塞文件描述符为非阻塞I/O。

同步I/O模型中，I/O读写操作都发生在I/O事件之后，由应用程序完成（将数据从内核缓冲区读入用户缓冲区，将数据从用户缓冲区写入内核缓冲区）。

### 阻塞I/O

accept，send，recv，connect等系统调用都可能被阻塞。

无法立即完成时将被操作系统挂起。

### 非阻塞I/O

非阻塞I/O的系统调用总是立即返回，不管时间是否发生。

没有发生返回-1，出错也返回-1，所以需要errno查看具体情况。

需要与I/O通知机制（I/O复用和SIGIO信号）一起使用

#### errno

accept，send，recv：事件未发生EAGAIN；EWOULDBLOCK期望阻塞。

connect：EINPROGRESS在处理中

### I/O通知机制

#### I/O复用

应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。

常用I/O复用函数：

```
select、poll、epoll_wait
```

#### SIGIO信号

我们可以为一个目标文件描述符指定宿主进程，被指定的宿主进程将捕获到SIGIO信号。

当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，此时就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作。

## 异步I/O模型

用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成后内核通知应用程序的方式。

异步I/O读写操作立即返回，而不论I/O是否阻塞，因为读写操作已经由内核接管。

也就是数据在内核缓冲区和用户缓冲区之间的移动由内核在“后台”完成。

## 事件处理模式

服务器程序通常要处理三类事件：I/O事件、信号事件、定时事件。

### Reactor模式

通常用同步I/O模型实现。

主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，若有就将该事件通知给工作线程（逻辑单元）。

除此以外，主线程不做任何实质性工作。

读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

### Proactor模式

其将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

通常用异步I/O模型实现。

### 模拟Proactor模式

用同步I/O模型模拟实现Proactor模式。

主线程执行读写操作，完成后向工作线程通知这一“完成事件”，从工作线程角度看，其就直接获得了数据读写的结果，接下来就对读写结果进行逻辑处理就行。