---
title: 机器学习-（数据预处理02·简）
description: 分类变量（类别变量编码）
pubDate: 2025-07-03
---

## Categorical Variables 分类变量

或称作类别变量编码，在实际应用中，我们需要对数据分类。很多时候标记或特征是字符串。如一项调查用户喜欢的汽车品牌，标记有“本田”，“丰田”，“大众“，”奔驰“等等，这时其无法直接代入模型拟合，做类别变量编码。

### Drop 删除

当某列的内容没有用，不影响，可以直接删除那一列。

### Ordinal Encoding 序数编码

此类要编码的属性值一般都有顺序属性。

如每周吃早餐的频率：每天>几乎每天>经常>很少>从不。这些属性值暗含有一种顺序或排序。

序数编码就是**将每个唯一的值分配给不同的整数**

```
每天-------4
几乎每天----3
经常-------2
很少-------1
从不-------0
```

### One-Hot Encoding 独热编码

此类编码会创造新的列，用来指示原始数据中存在（或不存在）每个可能的值。

一般用于没有暗含有排序或顺序关系的属性值。

如

| Color  |      | Red  | Green | Yellow |
| ------ | ---- | ---- | ----- | ------ |
| red    |      | 1    | 0     | 0      |
| green  |      | 0    | 1     | 0      |
| yellow |      | 0    | 0     | 1      |

用1表示存在，0表示不存在，这样便能知道原始数据是什么了。

但是此类编码方法在原始数据可能具有的值数量很多时性能不佳（如大于15）

## 代码实现

### 判断类型

通过检查每列的数据类型，若是`object`类型则代表是具有文本或其他类型（但能判断不是整数，这就够了，意味着我们需要对其编码）

```python
import pandas as pd
# 步骤1：判断每列的数据类型是否为object，返回布尔型Series
s = (X_train.dtypes == 'object')

# 步骤2：筛选出值为True的索引（即数据类型为object的列名）
object_cols = list(s[s].index)
```

### Drop 删除

`select_dtypes`是DataFrame的方法

```python
drop_X_train = X_train.select_dtypes(exclude=['object']) # exclude排除参数，还有include
drop_X_valid = X_valid.select_dtypes(exclude=['object'])
```

### Ordinal Encoding 序数编码

在scikit-learn的preprocessing（预处理）模块下有OrdinalEncoder类

```python
from sklearn.preprocessing import OrdinalEncoder
# 直接替换对应的列的属性值为的对应的序数编码
ordinal_encoder = OrdinalEncoder() # 默认handle_unknown='error' 测试集遇到训练集未见过类别会报错
label_X_train[object_cols] = ordinal_encoder.fit_transform(X_train[object_cols])
label_X_valid[object_cols] = ordinal_encoder.transform(X_valid[object_cols])
```

#### 例

##### 编码前

```python
# X_train
   Color  Size
0   red    M
1  blue    L
2  green   S

# X_valid
   Color  Size
0  blue    M
1  green   S
2   red    XL  # 训练集中未见过的类别
```

##### 编码后

```python
# label_X_train
   Color  Size
0      0     1  # red→0, M→1
1      1     2  # blue→1, L→2
2      2     0  # green→2, S→0

# label_X_valid
   Color  Size
0      1     1  # 沿用训练集的映射
1      2     0
2      0     ?  # 若handle_unknown='error'，XL会导致报错
```

### One-Hot Encoding 独热编码

在preprocessing模块下有OneHotEncoder类

```python
from sklearn.preprocessing import OneHotEncoder
# handle_unknown='ignore' 避免在验证数据包含训练数据中未表示的类时出现错误
# sparse=False 确保编码列作为 numpy 数组（而不是稀疏矩阵）返回
OH_encoder = OneHotEncoder(handle_unknown='ignore', sparse=False)
# 对分类特征编码
OH_cols_train = pd.DataFrame(OH_encoder.fit_transform(X_train[object_cols]))
OH_cols_valid = pd.DataFrame(OH_encoder.transform(X_valid[object_cols]))
# 恢复索引 从0，1，2...恢复为原来的索引名称
OH_cols_train.index = X_train.index
OH_cols_valid.index = X_valid.index
# 移除原分类列，保留数值列（编码后的列，避免特征重复）
num_X_train = X_train.drop(object_cols, axis=1) # 删除对应列
num_X_valid = X_valid.drop(object_cols, axis=1)
# 合并原其他数值特征与编码后的分类特征
OH_X_train = pd.concat([num_X_train, OH_cols_train], axis=1) # 表示按列合并，也就是水平合并
OH_X_valid = pd.concat([num_X_valid, OH_cols_valid], axis=1)
# 确保所有列名是字符串类型，某些模型（如 XGBoost）要求列名必须是字符串类型。若编码后的列名包含非字符串类型（如整数），会导致模型训练报错。
OH_X_train.columns = OH_X_train.columns.astype(str)
OH_X_valid.columns = OH_X_valid.columns.astype(str)
```

#### 例

##### 编码前

```python
   Age  Color  Height
0   25    red     180
1   30   blue     175
2   35  green     190
```

##### 编码后

```python
   Age  Height  Color_red  Color_blue  Color_green
0   25     180          1           0            0
1   30     175          0           1            0
2   35     190          0           0            1
```

## 总结

一般来说，One-Hot Encoding效果最好，Drop最差，但也要根据情况而定。