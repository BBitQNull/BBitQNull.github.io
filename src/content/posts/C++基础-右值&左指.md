---
title: C++基础-右值&左指-01
description: 讲解C++中右值与左值的概念
pubDate: 2025-07-15
---

# 基本概念

## 右值

**只能**出现在赋值表达式右侧的临时对象，没有持久的内存地址。

无名称、不可寻址、生命周期短暂。

#### 举例

```c++
int x = 5; // 5这个int字面量是右值
int y = 5 + 3; // 5+3这个临时结果是右值
std::string s = "hello world!"; // hello world！这个字符串字面量是右值
77； // 77这个int字面量是右值
int z = func(x); // func(x)这个函数调用是右值
```

### 右值的分类

#### 纯右值

传统意义上的右值，就是字面量，临时对象等。

#### 将亡值

通过右值引用（T&&）产生的临时对象，通常用于移动语义

```c++
std::vector<int> w = std::move(v);  // std::move(v) 是将亡值
// std::move
/*
将左值强制转换为右值引用，标记该对象可以被 “移动”
std::move 不移动任何东西，只是一个类型转换 static_cast<T&&>
*/
```

### 右值引用

右值引用是一种特殊的引用类型，只能绑定到右值，语法为 T&&。

可以实现：

- **实现移动语义**：避免不必要的深拷贝。
- **完美转发**：在模板中保持参数的值类别。

#### 举例

```c++
int&& rref = 5;  // 右值引用，绑定到右值（临时对象）
rref = 20;       // 可以修改临时对象
```

### 移动语义

移动语义的核心是资源所有权的转移，而非资源内容的复制。可以高效处理临时对象，避免复制开销；可以实现资源的独占性。

#### 触发条件

```c++
// 临时对象初始化新对象，直接将该临时对象资源所有权转移
MyVector v1 = createVector();  // createVector() 返回临时对象
// 显式使用std::move
MyVector v1(10);
MyVector v2 = std::move(v1);   // 将左值强制转为右值
// 容器操作
std::vector<MyVector> vec;
vec.push_back(MyVector(10));   // 临时对象触发移动构造
```

#### 优势

1. 性能提升：

   避免深拷贝，直接转移资源所有权，大幅提高效率。

   对临时对象的操作几乎无开销。

2. 资源管理安全：

   原对象放弃资源后，无法再访问已转移的资源。

   资源始终由一个对象拥有，避免双重释放。

3. 实现移动 - only 类型：

   某些资源（如文件句柄、网络连接）不适合复制，但可安全移动。

   通过禁用拷贝构造，仅保留移动构造，可创建 “只能移动” 的类型。

## 左值

**可以**出现在赋值表达式左侧（也可以在右边）的表达式，具有持久的内存地址。

有名称、可寻址、生命周期较长。

#### 举例

```c++
int x = 5; // x是左值
int y = 5 + 3; // y是左值
std::string s = "hello world!"; // s是左值
int z = func(x); // z是左值
```

### 左值引用

左值引用是对左值（具有持久内存地址的对象）的引用，语法为 T&。

只能绑定到左值不能绑定到右值。避免拷贝。

#### 常量左值引用

语法是const T&。

可以绑定到右值，常用于函数参数以接受任意类型的实参（左值或右值），同时避免拷贝

#### 举例

```c++
int x = 10;
int& ref = x;  // 左值引用，绑定到左值x
ref = 20;      // 修改引用，即修改x

// 错误：不能直接绑定右值
// int& invalid_ref = 5;  // 编译错误：无法将右值绑定到左值引用
```

```c++
void func(const int& value) {
    // 可以接受左值或右值
}

func(x);     // 合法：左值
func(10);    // 合法：右值（常量左值引用可绑定右值）
```
